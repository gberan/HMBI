/*******************************************************/
/* Copyright (c) 2005-2009 by Ziena Optimization, Inc. */
/* All Rights Reserved                                 */
/*******************************************************/

/* KNITRO 7.0 application interface header file. */

#ifndef KNITRO_H__
#define KNITRO_H__


#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif


/*------------------------------------------------------------------*/
/*     EXPORT MACROS                                                */
/*------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _WIN32
  #ifdef MAKE_KNITRO_DLL
    #define KNITRO_API __declspec(dllexport) __stdcall
  #else
    #define KNITRO_API __stdcall
  #endif
#else
  #define KNITRO_API
#endif


/*------------------------------------------------------------------*/
/*     FORWARD DECLARATION TYPE DEFINITIONS                         */
/*------------------------------------------------------------------*/

/** Type declaration for the KNITRO solver context object.
 *  All methods pass a pointer to the solver.
 *  Applications must not modify any part of the solver context,
 *  except by making KNITRO API calls.
 */
typedef struct KTR_context KTR_context, *KTR_context_ptr;   

/** Type declaration for the callback that allows applications to handle
 *  output.  The function should return the number of characters that
 *  were printed.  See KTR_set_puts_callback for more information.
 */
typedef int  KTR_puts (const char * const  str,
                             void * const  userParams);

/** Type declaration for the Ziena License Manager context object.
 *  Applications must not modify any part of the context.
 */
typedef struct ZLM_context ZLM_context, *ZLM_context_ptr;


/*------------------------------------------------------------------*/
/*     FUNCTION DECLARATIONS                                        */
/*------------------------------------------------------------------*/

/* -----  Creating and destroying solver objects ----- */

/** Call KTR_new or KTR_new_puts first.  Either returns a pointer to the
 *  solver object that is used in all other KNITRO API calls.
 *  A new KNITRO license is acquired and held until KTR_free has been called,
 *  or until the calling program ends.
 *  Returns NULL on error.
 */
KTR_context_ptr  KNITRO_API KTR_new (void);

/** Call KTR_new or KTR_new_puts first.  Either returns a pointer to the
 *  solver object that is used in all other KNITRO API calls.
 *  A new KNITRO license is acquired and held until KTR_free has been called,
 *  or until the calling program ends.
 *  This function also takes an argument that sets a "put string" callback
 *  function to handle output generated by the KNITRO solver, and a pointer
 *  for passing user-defined data.  See KTR_set_puts_callback for more
 *  information.
 *  Returns NULL on error.
 */
KTR_context_ptr  KNITRO_API KTR_new_puts (KTR_puts * const  fnPtr,
                                          void     * const  userParams);

/** Free all memory and release any KNITRO license acquired by calling
 *  KTR_new or KTR_new_puts.  The address of the pointer is set to NULL
 *  after freeing memory, to help avoid mistakes.
 *  Returns 0 if OK, nonzero if error.
 */
int  KNITRO_API KTR_free (KTR_context_ptr *  kc_handle);


/* -----  Creating and destroying solvers in high volume ----- */

/** High volume applications construct new KNITRO instances repeatedly,
 *  each lasting only a short time.  Special functions allow a single
 *  license to be checked out once for a sequence of KNITRO instances.
 *  Reusing a license saves time in the KNITRO solver, and improves the
 *  performance of the Ziena License Manager server.
 *
 *  The typical calling sequence is:
 *    ZLM_checkout_license
 *      KTR_new_zlm
 *        KTR_init_problem
 *        KTR_solve (a single call, or a reverse communications loop)
 *      KTR_free
 *      KTR_new_zlm
 *        KTR_init_problem
 *        KTR_solve (a single call, or a reverse communications loop)
 *      KTR_free
 *      ...
 *    ZLM_release_license
 *
 *  High volume functions are not available in the "student" version.
 *  Please see the Ziena License Manager user manual for more information.
 */

/** Allocate memory for a license from the Ziena License Manager for high
 *  volume KNITRO applications.  The license will be checked out the first
 *  time KTR_new_zlm is called.  The license must be checked in later by
 *  calling ZLM_release_license.
 *  Returns NULL on error.
 */
ZLM_context_ptr  KNITRO_API ZLM_checkout_license (void);

/** Returns a pointer to the solver object that is used in all other KNITRO
 *  API calls.  Pass the license acquired by calling ZLM_checkout_license.
 *  This function also takes an argument that sets a "put string" callback
 *  function to handle output generated by the KNITRO solver, and a pointer
 *  for passing user-defined data.  See KTR_set_puts_callback for more
 *  information.
 *  Returns NULL on error.
 */
KTR_context_ptr  KNITRO_API KTR_new_zlm (KTR_puts    * const  fnPtr,
                                         void        * const  userParams,
                                         ZLM_context * const  pZLMcontext);

/** Release the KNITRO license and free allocated memory.
 *  KNITRO will set the address of the pointer to NULL after freeing
 *  memory, to help avoid mistakes.
 *  Returns 0 if OK, nonzero if error.
 */
int  KNITRO_API ZLM_release_license (ZLM_context *  pZLMcontext);


/* ----- Changing and reading solver parameters ----- */

/** Parameters cannot be set after KNITRO begins solving; ie, after
 *  the KTR_solve function is called.  They may be set again after
 *  calling KTR_reset.
 *    All methods return 0 if OK, nonzero if there was an error.
 *  In most cases, parameter values are not validated until
 *  KTR_init_problem or KTR_solve is called.
 */

/** Reset all parameters to default values.
 */
int  KNITRO_API KTR_reset_params_to_defaults (KTR_context_ptr  kc);


/** Set all parameters specified in the given file. */
int  KNITRO_API KTR_load_param_file
    (KTR_context_ptr  kc, const char * const  filename);

/** Write all current parameter values to a file. */
int  KNITRO_API KTR_save_param_file
    (KTR_context_ptr  kc, const char * const  filename);

/** Set a parameter using its string name. */
int  KNITRO_API KTR_set_int_param_by_name
    (KTR_context_ptr  kc, const char * const  name, const int  value);
int  KNITRO_API KTR_set_char_param_by_name
    (KTR_context_ptr  kc, const char * const  name, const char * const  value);
int  KNITRO_API KTR_set_double_param_by_name
    (KTR_context_ptr  kc, const char * const  name, const double  value);

/** Set a parameter using its integer identifier KTR_PARAM_x (defined below). */
int  KNITRO_API KTR_set_int_param
    (KTR_context_ptr  kc, const int  param_id, const int  value);
int  KNITRO_API KTR_set_char_param
    (KTR_context_ptr  kc, const int  param_id, const char * const  value);
int  KNITRO_API KTR_set_double_param
    (KTR_context_ptr  kc, const int  param_id, const double  value);

/** Get a parameter using its string name. */
int  KNITRO_API KTR_get_int_param_by_name
    (KTR_context_ptr  kc, const char * const  name, int * const  value);
int  KNITRO_API KTR_get_double_param_by_name
    (KTR_context_ptr  kc, const char * const  name, double * const  value);

/** Get a parameter using its integer identifier KTR_PARAM_x (defined below). */
int  KNITRO_API KTR_get_int_param
    (KTR_context_ptr  kc, const int  param_id, int * const  value);
int  KNITRO_API KTR_get_double_param
    (KTR_context_ptr  kc, const int  param_id, double * const  value);

/** Copy the KNITRO release name into "release".  This variable must be
 *  preallocated to have "length" elements, including the string termination
 *  character.  For compatibility with future releases, please allocate at
 *  least 15 characters. */
void  KNITRO_API KTR_get_release
    (const int  length, char * const  release);


/* ----- Problem modification ----- */

/** This function adds complementarity constraints to the problem.
 *  It must be called after KTR_init_problem and before KTR_solve.
 *    The two lists are of equal length, and contain matching pairs of
 *  variable indices.  Each pair defines a complementarity constraint
 *  between the two variables.  The function can be called more than once
 *  to accumulate a long list of complementarity constraints in KNITRO's
 *  internal problem definition.
 *
 *  Returns 0 if OK, or a negative value on error.
 */
int  KNITRO_API KTR_addcompcons (KTR_context_ptr    kc,
                                 const int          numCompConstraints,
                                 const int * const  indexList1,
                                 const int * const  indexList2);


/* ----- Solving ----- */

/** Problem structure is passed to KNITRO using KTR_init_problem.
 *    The problem is solved by calling KTR_solve.  Applications must
 *  provide a means of evaluating the nonlinear objective, constraints,
 *  first derivatives, and (optionally) second derivatives.  (First
 *  derivatives are also optional, but highly recommended.)
 *    If the application provides callback functions for making evaluations
 *  (see KTR_callback below), then a single call to KTR_solve will return
 *  the solution.  Alternatively, the application can employ a reverse
 *  communications driver.  In this case, KTR_solve returns a status code
 *  whenever it needs evaluation data (see examples/C/reverseCommExample.c).
 *
 *  The typical calling sequence is:
 *    KTR_new
 *    KTR_init_problem
 *    KTR_set_xxx_param (set any number of parameters)
 *    KTR_solve (a single call, or a reverse communications loop)
 *    KTR_free
 *
 *  Calling sequence if two different problems are to be solved
 *  with the same KNITRO solver instance:
 *    KTR_new
 *    KTR_init_problem
 *    KTR_set_xxx_param (set any number of parameters)
 *    KTR_solve (a single call, or a reverse communications loop)
 *    KTR_init_problem
 *    KTR_set_xxx_param (set any number of parameters)
 *    KTR_solve (a single call, or a reverse communications loop)
 *    KTR_free
 *
 *  Calling sequence if the same problem is to be solved again,
 *  with different parameters or a different start point:
 *    KTR_new
 *    KTR_init_problem
 *    KTR_set_xxx_param (set any number of parameters)
 *    KTR_solve (a single call, or a reverse communications loop)
 *    KTR_restart
 *    KTR_set_xxx_param (set any number of parameters)
 *    KTR_solve (a single call, or a reverse communications loop)
 *    KTR_free
 *
 *  For MIP problems, use KTR_mip_init_problem and KTR_mip_solve
 *  instead of KTR_init_problem and KTR_solve. 
 */

/** Initialize KNITRO with a new problem.  KNITRO makes a local copy of
 *  all inputs, so the application may free memory after the call
 *  completes.  Arrays cannot be NULL, except as follows:
 *  - If "xLoBnds" or "xUpBnds" are NULL, then KNITRO assumes all variables
 *    are unbounded in that direction.
 *  - If the application does not supply an exact Hessian, then pass nnzH=0
 *    and NULL pointers for "hessIndexRows" and "hessIndexCols".
 *  - If "xInitial" or "lambdaInitial" are NULL, then KNITRO determines the
 *    initial start point.
 *  If a particular bound does not exist, then load the array element
 *  with KTR_INFBOUND for an upper bound, or -KTR_INFBOUND for a lower bound.
 *  KNITRO interprets this value as infinity and ignores the bound.
 *    To make the j-th constraint be an equality constraint, set cLoBnds[j]
 *  equal to cUpBnds[j].
 *
 *  Returns 0 if OK, nonzero if error.
 *
 *  Brief description of the arguments (consult the KNITRO manual for details):
 *    n             - number of unknowns
 *    objGoal       - objective goal (KTR_OBJGOAL_MINIMIZE or _MAXIMIZE)
 *    objType       - objective type (eg, KTR_OBJTYPE_GENERAL)
 *    xLoBnds       - (length n) lower bounds on the variables
 *    xUpBnds       - (length n) upper bounds on the variables
 *    m             - number of constraints
 *    cType         - (length m) constraint type (eg, KTR_CONTYPE_GENERAL)
 *    cLoBnds       - (length m) lower bounds on the constraints
 *    cUpBnds       - (length m) upper bounds on the constraints
 *    nnzJ          - number of nonzeroes in the sparse constraint Jacobian
 *    jacIndexVars  - (length nnzJ) variable index (column) of each nonzero
 *    jacIndexCons  - (length nnzJ) constraint index (row) of each nonzero
 *    nnzH          - number of nonzeroes in the sparse Hessian of Lagrangian
 *    hessIndexRows - (length nnzH) row index of each nonzero
 *    hessIndexCols - (length nnzH) column index of each nonzero
 *    xInitial      - (length n) initial start point for the unknowns
 *    lambdaInitial - (length m+n) initial start point for multipliers
 */
int  KNITRO_API KTR_init_problem (KTR_context_ptr       kc,
                                  const int             n,
                                  const int             objGoal,
                                  const int             objType,
                                  const double * const  xLoBnds,
                                  const double * const  xUpBnds,
                                  const int             m,
                                  const int    * const  cType,
                                  const double * const  cLoBnds,
                                  const double * const  cUpBnds,
                                  const int             nnzJ,
                                  const int    * const  jacIndexVars,
                                  const int    * const  jacIndexCons,
                                  const int             nnzH,
                                  const int    * const  hessIndexRows,
                                  const int    * const  hessIndexCols,
                                  const double * const  xInitial,
                                  const double * const  lambdaInitial);

        
/** Call KNITRO to solve the problem.  If the application provides callback
 *  functions for evaluating the function, constraints, and derivatives,
 *  then a single call to KTR_solve returns the solution.  Otherwise,
 *  KNITRO operates in reverse communications mode and returns a status code
 *  that may request another call.  See the KNITRO manual for details.
 *
 *  Returns one of the status codes KTR_RC_* (see definitions in this file).
 *  In particular:
 *    <0 - KNITRO terminated with a fatal error
 *     0 - KNITRO is finished: x, lambda, and obj contain the optimal solution
 *     1 - call KTR_solve again (reverse comm) with obj and c containing
 *         the objective and constraints evaluated at x
 *     2 - call KTR_solve again (reverse comm) with objGrad and jac containing
 *         the objective and constraint first derivatives evaluated at x
 *     3 - call KTR_solve again (reverse comm) with hess containing
 *         H(x,lambda), the Hessian of the Lagrangian evaluated at x and lambda
 *     7 - call KTR_solve again (reverse comm) with hessVector containing
 *         the result of H(x,lambda) * hessVector
 *
 *  Brief description of the arguments (consult the KNITRO manual for details):
 *    x          - output (length n) solution point estimate
 *    lambda     - output (length m+n) Lagrange multiplier estimate
 *    evalStatus - input  evaluation status (0=OK)
 *    obj        - input  (length 1) objective at x
 *                 output            optimal objective if KTR_RC_BEGINEND
 *    c          - input  (length m) constraints at x
 *    objGrad    - input  (length n) objective gradient at x
 *    jac        - input  (length nnzJ) sparse constraint gradient at x
 *    hess       - input  (length nnzH) sparse Hessian at x and lambda
 *    hessVector - input  (length n) vector to multiply Hessian by
 *                 output            result of H(x,lambda) * hessVector
 *    userParams - input  passed directly to application callback functions
 *
 *  If "gradopt" is set to compute finite differences for first derivatives,
 *  then KTR_solve will modify objGrad and jac; otherwise, these arguments
 *  are not modified.
 */
int  KNITRO_API KTR_solve ( KTR_context_ptr      kc,
                                 double * const  x,
                                 double * const  lambda,
                           const int             evalStatus,
                                 double * const  obj,
                           const double * const  c,
                                 double * const  objGrad,
                                 double * const  jac,
                           const double * const  hess,
                                 double * const  hessVector,
                                 void   * const  userParams);

        
/** Prepare KNITRO to restart the current problem at a new start point.
 *  If output to a file is enabled, this will erase the current file.
 *  KNITRO parameter values are not changed by this call.
 *  Returns 0 if OK, nonzero if error.
 */
int  KNITRO_API KTR_restart (KTR_context_ptr       kc,
                             const double * const  xInitial,
                             const double * const  lambdaInitial);


/** For MIP problems, use KTR_mip_init_problem and KTR_mip_solve
 *  instead of KTR_init_problem and KTR_solve. 
 */
    
/** Initialize KNITRO with a new MIP problem.  KNITRO makes a local copy of
 *  all inputs, so the application may free memory after the call
 *  completes.  Arrays cannot be NULL, except as follows:
 *  - If "xLoBnds" or "xUpBnds" are NULL, then KNITRO assumes all continuous
 *    variables are unbounded in that direction.
 *  - If "yLoBnds" or "yUpBnds" are NULL, then KNITRO assumes all integer
 *    variables are unbounded in that direction.
 *  - If the application does not supply an exact Hessian, then pass nnzH=0
 *    and NULL pointers for "hessIndexRows" and "hessIndexCols".
 *  - If "xInitial" or "lambdaInitial" are NULL, then KNITRO determines the
 *    initial start point.
 *  If a particular bound does not exist, then load the array element
 *  with KTR_INFBOUND for an upper bound, or -KTR_INFBOUND for a lower bound.
 *  KNITRO interprets this value as infinity and ignores the bound.
 *    To make the j-th constraint be an equality constraint, set cLoBnds[j]
 *  equal to cUpBnds[j].
 *
 *  Returns 0 if OK, nonzero if error.
 *
 *  Brief description of the arguments (consult the KNITRO manual for details):
 *    n             - number of unknowns (continuous and integer)
 *    objGoal       - objective goal (KTR_OBJGOAL_MINIMIZE or _MAXIMIZE)
 *    objType       - objective type (eg, KTR_OBJTYPE_GENERAL)
 *    objFnType     - objective function type (eg, KTR_FNTYPE_CONVEX)
 *    xType         - (length n) variable type (eg, KTR_VARTYPE_INTEGER)
 *    xLoBnds       - (length n) lower bounds on the variables
 *    xUpBnds       - (length n) upper bounds on the variables
 *    m             - number of constraints
 *    cType         - (length m) constraint type (eg, KTR_CONTYPE_GENERAL)
 *    cFnType       - (length m) constraint function type (eg, KTR_FNTYPE_CONVEX)
 *    cLoBnds       - (length m) lower bounds on the constraints
 *    cUpBnds       - (length m) upper bounds on the constraints
 *    nnzJ          - number of nonzeroes in the sparse constraint Jacobian
 *    jacIndexVars  - (length nnzJ) variable index (column) of each nonzero
 *    jacIndexCons  - (length nnzJ) constraint index (row) of each nonzero
 *    nnzH          - number of nonzeroes in the sparse Hessian of Lagrangian
 *    hessIndexRows - (length nnzH) row index of each nonzero
 *    hessIndexCols - (length nnzH) column index of each nonzero
 *    xInitial      - (length n) initial start point for the unknowns
 *    lambdaInitial - (length m+n) initial start point for multipliers
 */
int  KNITRO_API KTR_mip_init_problem
    (      KTR_context_ptr kc,
     const int             n,
     const int             objGoal,
     const int             objType,
     const int             objFnType,
     const int    * const  xType,
     const double * const  xLoBnds,
     const double * const  xUpBnds,
     const int             m,
     const int    * const  cType,
     const int    * const  cFnType,
     const double * const  cLoBnds,
     const double * const  cUpBnds,
     const int             nnzJ,
     const int    * const  jacIndexVars,
     const int    * const  jacIndexCons,
     const int             nnzH,
     const int    * const  hessIndexRows,
     const int    * const  hessIndexCols,
     const double * const  xInitial,
     const double * const  lambdaInitial);


/** Set the branching priorities for integer variables.
 *  Priorities must be positive numbers (variables with non-positive values
 *  are ignored).  Variables with higher priority values will be considered
 *  for branching before variables with lower priority values.  When
 *  priorities for a subset of variables are equal, the branching rule is
 *  applied as a tiebreaker.
 *  Array xPriorities has length n, and values for continuous variables are
 *  ignored.  KNITRO makes a local copy of all inputs, so the application
 *  may free memory after the call.
 *  This routine must be called after calling KTR_mip_init_problem and
 *  before calling KTR_mip_solve.
 *  Returns 0 if OK, nonzero if error.
 */
int  KNITRO_API KTR_mip_set_branching_priorities
    (      KTR_context_ptr kc,
     const int * const     xPriorities);


/** Call KNITRO to solve the MIP problem.  If the application provides callback
 *  functions for evaluating the function, constraints, and derivatives,
 *  then a single call to KTR_mip_solve returns the solution.  Otherwise,
 *  KNITRO operates in reverse communications mode and returns a status code
 *  that may request another call.  See the KNITRO manual for details.
 *
 *  Returns one of the status codes KTR_RC_* (see definitions in this file).
 *  In particular:
 *    <0 - KNITRO terminated with a fatal error
 *     0 - KNITRO is finished: x, lambda, and obj contain the optimal solution
 *     1 - call KTR_mip_solve again (reverse comm) with obj and c containing
 *         the objective and constraints evaluated at x
 *     2 - call KTR_mip_solve again (reverse comm) with objGrad and jac
 *         containing the objective and constraint first derivatives evaluated
 *         at x
 *     3 - call KTR_mip_solve again (reverse comm) with hess containing
 *         H(x,lambda), the Hessian of the Lagrangian evaluated at x and lambda
 *     7 - call KTR_mip_solve again (reverse comm) with hessVector containing
 *         the result of H(x,lambda) * hessVector
 *
 *  Brief description of the arguments (consult the KNITRO manual for details):
 *    x          - output (length n) solution point estimate
 *    lambda     - output (length m+n) Lagrange multiplier estimate
 *    evalStatus - input  evaluation status (0=OK)
 *    obj        - input  (length 1) objective at x
 *                 output            optimal objective if KTR_RC_BEGINEND
 *    c          - input  (length m) constraints at x
 *    objGrad    - input  (length n) objective gradient at x
 *    jac        - input  (length nnzJ) sparse constraint gradient at x
 *    hess       - input  (length nnzH) sparse Hessian at x and lambda
 *    hessVector - input  (length n) vector to multiply Hessian by
 *                 output            result of H(x,lambda) * hessVector
 *    userParams - input  passed directly to application callback functions
 *
 *  If "gradopt" is set to compute finite differences for first derivatives,
 *  then KTR_mip_solve will modify objGrad and jac; otherwise, these arguments
 *  are not modified.
 */
int  KNITRO_API KTR_mip_solve
    (      KTR_context_ptr kc,
           double * const  x,
           double * const  lambda,
     const int             evalStatus,
           double * const  obj,
           double * const  c,
           double * const  objGrad,
           double * const  jac,
           double * const  hess,
           double * const  hessVector,
           void   * const  userParams);
    
    
/* ----- Callbacks ----- */

/** Applications may define functions for evaluating problem elements
 *  at a trial point.  The functions must match the prototype defined
 *  below, and passed to KNITRO with the appropriate KTR_set_func_x call.
 *  KNITRO may request four different types of evaluation information,
 *  as specified in "evalRequestCode":
 *    KTR_RC_EVALFC - return objective and constraint function values
 *    KTR_RC_EVALGA - return first derivative values in "objGrad" and "jac"
 *    KTR_RC_EVALH  - return second derivative values in "hessian"
 *    KTR_RC_EVALHV - return a Hessian-vector product in "hessVector"
 *
 *  The argument "lambda" is not defined when requesting EVALFC or EVALGA.
 *    Usually, applications define 3 callback functions, one for EVALFC,
 *  one for EVALGA, and one for EVALH / EVALHV.  The last function
 *  evaluates H or HV depending on the value of "evalRequestCode".
 *    It is possible to combine EVALFC and EVALGA into a single function,
 *  because "x" changes only for an EVALFC request.  This is advantageous
 *  if the application evaluates functions and their derivatives at the same
 *  time.  Pass the same callback function in KTR_set_func_callback
 *  and KTR_set_grad_callback, have it populate "obj", "c", "objGrad",
 *  and "jac" for an EVALFC request, and do nothing for an EVALGA request.
 *    Do not combine EVALFC and EVALGA if hessopt = KTR_HESSOPT_FINITE_DIFF,
 *  because the finite difference Hessian changes x and calls EVALGA without
 *  calling EVALFC first.
 *    It is not possible to combine EVALH / EVALHV because "lambda" changes
 *  after the EVALFC call.
 *
 *  The "userParams" argument is an arbitrary pointer passed from the KNITRO
 *  KTR_solve call to the callback.  It should be used to pass parameters
 *  defined and controlled by the application, or left null if not used.
 *  KNITRO does not modify or dereference the "userParams" pointer.
 *
 *  Callbacks should return 0 if successful, a negative error code if not.
 */

typedef int KTR_callback (const int             evalRequestCode,
                          const int             n,
                          const int             m,
                          const int             nnzJ,
                          const int             nnzH,
                          const double * const  x,
                          const double * const  lambda,
                                double * const  obj,
                                double * const  c,
                                double * const  objGrad,
                                double * const  jac,
                                double * const  hessian,
                                double * const  hessVector,
                                void   *        userParams);

/** Set the callback function that evaluates "obj" and "c" at x.
 *  It may also evaluate "objGrad" and "jac" if EVALFC and EVALGA are
 *  combined into a single call.
 *  Do not modify "hessian" or "hessVector".
 */
int  KNITRO_API KTR_set_func_callback (KTR_context_ptr       kc,
                                       KTR_callback * const  fnPtr);

/** Set the callback function that evaluates "objGrad" and "jac" at x.
 *  It may do nothing if EVALFC and EVALGA are combined into a single call.
 *  Do not modify "hessian" or "hessVector".
 */
int  KNITRO_API KTR_set_grad_callback (KTR_context_ptr       kc,
                                       KTR_callback * const  fnPtr);

/** Set the callback function that evaluates second derivatives at (x, lambda).
 *  If "evalRequestCode" equals KTR_RC_EVALH, then the function must
 *  return nonzeroes in "hessian".  If it equals KTR_RC_EVALHV, then the
 *  function multiplies second derivatives by "hessVector" and returns the
 *  product in "hessVector".
 *  Do not modify "obj", "c", "objGrad", or "jac".
 */
int  KNITRO_API KTR_set_hess_callback (KTR_context_ptr       kc,
                                       KTR_callback * const  fnPtr);

/** Set the callback function that is invoked after KNITRO computes a
 *  new estimate of the solution point (i.e., after every major iteration).
 *  The function should not modify any KNITRO arguments.
 *  Arguments "x" and "lambda" contain the new point and values.
 *  Arguments "obj" and "c" contain objective and constraint values at "x".
 *  First and second derivative arguments are not defined and should not
 *  be examined.
 */
int  KNITRO_API KTR_set_newpoint_callback (KTR_context_ptr       kc,
                                           KTR_callback * const  fnPtr);

/** Applications can set a "put string" callback function to handle output
 *  generated by the KNITRO solver.  By default KNITRO prints to stdout
 *  or a file named "knitro.out" file, as determined by KTR_PARAM_OUTMODE.
 *  The KTR_puts function takes a "userParams" argument which is a
 *  a pointer passed directly from KTR_solve.  Note that "userParams" will
 *  be a NULL pointer until defined by an application call to KTR_new_puts
 *  or KTR_solve.
 */
int  KNITRO_API KTR_set_puts_callback (KTR_context_ptr   kc,
                                       KTR_puts * const  fnPtr);


/* ----- Reading solution properties ----- */

/** Return the number of function evaluations requested by KTR_solve.
 *  A single request evaluates the objective and all constraint functions.
 *  Returns a negative number if there is a problem with kc.
 */
int  KNITRO_API KTR_get_number_FC_evals (const KTR_context_ptr  kc);

/** Return the number of gradient evaluations requested by KTR_solve.
 *  A single request evaluates first derivatives of the objective and
 *  all constraint functions.
 *  Returns a negative number if there is a problem with kc.
 */
int  KNITRO_API KTR_get_number_GA_evals (const KTR_context_ptr  kc);

/** Return the number of Hessian evaluations requested by KTR_solve.
 *  A single request evaluates second derivatives of the objective and
 *  all constraint functions.
 *  Returns a negative number if there is a problem with kc.
 */
int  KNITRO_API KTR_get_number_H_evals (const KTR_context_ptr  kc);

/** Return the number of Hessian-vector products requested by KTR_solve.
 *  A single request evaluates the product of the Hessian of the
 *  Lagrangian with a vector submitted by KNITRO.
 *  Returns a negative number if there is a problem with kc.
 */
int  KNITRO_API KTR_get_number_HV_evals (const KTR_context_ptr  kc);

/** Return the number of iterations made by KTR_solve.
 *  Returns a negative number if there is a problem with kc.
 */
int  KNITRO_API KTR_get_number_iters (const KTR_context_ptr  kc);
    
/** Return the number of major iterations made by KTR_solve.
 *  Returns a negative number if there is a problem with kc.
 *  (DEPRECATED, BUT KEPT FOR NOW FOR BACKWARDS COMPATIBILITY)
 */
int  KNITRO_API KTR_get_number_major_iters (const KTR_context_ptr  kc);

/** Return the number of minor iterations made by KTR_solve.
 *  Returns a negative number if there is a problem with kc.
 *  (DEPRECATED, BUT KEPT FOR NOW FOR BACKWARDS COMPATIBILITY)
 */
int  KNITRO_API KTR_get_number_minor_iters (const KTR_context_ptr  kc);

/** Return the absolute feasibility error at the solution.
 *  Refer to the KNITRO manual section on Termination Tests for a
 *  detailed definition of this quantity.
 *  Returns a negative number if there is a problem with kc.
 */
double  KNITRO_API KTR_get_abs_feas_error (const KTR_context_ptr  kc);

/** Return the relative feasibility error at the solution.
 *  Refer to the KNITRO manual section on Termination Tests for a
 *  detailed definition of this quantity.
 *  Returns a negative number if there is a problem with kc.
 */
double  KNITRO_API KTR_get_rel_feas_error (const KTR_context_ptr  kc);
    
/** Return the absolute optimality error at the solution.
 *  Refer to the KNITRO manual section on Termination Tests for a
 *  detailed definition of this quantity.
 *  Returns a negative number if there is a problem with kc.
 */
double  KNITRO_API KTR_get_abs_opt_error (const KTR_context_ptr  kc);

/** Return the relative optimality error at the solution.
 *  Refer to the KNITRO manual section on Termination Tests for a
 *  detailed definition of this quantity.
 *  Returns a negative number if there is a problem with kc.
 */
double  KNITRO_API KTR_get_rel_opt_error (const KTR_context_ptr  kc);

/** Return the number of nodes processed in the MIP solve.
 *  Returns a negative number if there is a problem with kc.    
 */
int  KNITRO_API KTR_get_mip_num_nodes (const KTR_context_ptr kc);
    
/** Return the number of continuous subproblems processed in the
 *  MIP solve.
 *  Returns a negative number if there is a problem with kc.
 */
int  KNITRO_API KTR_get_mip_num_solves (const KTR_context_ptr kc);
    
/** Return the final absolute integrality gap in the MIP solve.
 *  Refer to the KNITRO manual section on Termination Tests for
 *  a detailed definition of this quantity. Returns KTR_INFBOUND
 *  if no incumbent (i.e., integer feasible) point found.
 *  Returns KTR_RC_BAD_KCPTR if there is a problem with kc.
 */
double  KNITRO_API KTR_get_mip_abs_gap (const KTR_context_ptr kc);    

/** Return the final absolute integrality gap in the MIP solve.
 *  Refer to the KNITRO manual section on Termination Tests for
 *  a detailed definition of this quantity.  Returns KTR_INFBOUND
 *  if no incumbent (i.e., integer feasible) point found.
 *  Returns KTR_RC_BAD_KCPTR if there is a problem with kc.
 */
double  KNITRO_API KTR_get_mip_rel_gap (const KTR_context_ptr kc); 

/** Return the objective value of the MIP incumbent solution.
 *  Returns KTR_INFBOUND if no incumbent (i.e., integer feasible)
 *  point found.
 *  Returns KTR_RC_BAD_KCPTR if there is a problem with kc.
 */
double  KNITRO_API KTR_get_mip_incumbent_obj (const KTR_context_ptr kc);

/** Return the value of the current MIP relaxation bound.
 *  Returns KTR_RC_BAD_KCPTR if there is a problem with kc.
 */
double  KNITRO_API KTR_get_mip_relaxation_bnd (const KTR_context_ptr kc);

/** Return the objective value of the most recently solved MIP
 *  node subproblem.
 *  Returns KTR_RC_BAD_KCPTR if there is a problem with kc.
 */
double  KNITRO_API KTR_get_mip_lastnode_obj (const KTR_context_ptr kc);

/** Return the MIP incumbent solution in "x" if one exists.
 *  Returns 1 if incumbent solution exists and call is successful;
 *          0 if no incumbent (i.e., integer feasible) exists
 *              and leaves "x" unmodified;
 *         <0 if there is an error.
 */
int  KNITRO_API KTR_get_mip_incumbent_x (const KTR_context_ptr kc,
                                         double * const x);
    
/* ----- Checking derivatives ----- */

/** Compare the application's analytic first derivatives to a finite
 *  difference approximation at x.  The objective and all constraint
 *  functions are checked.  Like KTR_solve, the routine may be used in
 *  reverse communications or callback mode (see examples/C/checkDersExample.c).
 *
 *  Returns one of the status codes KTR_RC_* (see definitions in this file).
 *  In particular:
 *    <0 - error
 *     0 - routine is finished
 *     1 - call routine again (reverse comm) with obj and c containing
 *         the objective and constraints evaluated at x
 *     2 - call routine again (reverse comm) with objGrad and jac containing
 *         the objective and constraint first derivatives evaluated at x
 *
 *  Description of the arguments:
 *    x                - input  (length n) point at which to check derivatives
 *                       output            point at which to evaluate obj and c
 *    finiteDiffMethod - 1 = forward differences, 2 = central differences
 *    absThreshold     - print when |estimate - analytic| > threshold
 *    relThreshold     - print when |estimate - analytic| > threshold * scale
 *                         where scale = max{1, |analytic|}
 *    evalStatus       - input            evaluation status (0=OK)
 *    obj              - input            objective at x
 *    c                - input (length m) constraints at x
 *    objGrad          - input (length n) analytic gradient at x
 *    jac              - input (length nnzJ) analytic constraint Jacobian at x
 *    userParams       - input  passed directly to application callback
 */
int  KNITRO_API KTR_check_first_ders (const KTR_context_ptr  kc,
                                            double * const   x,
                                      const int              finiteDiffMethod,
                                      const double           absThreshold,
                                      const double           relThreshold,
                                      const int              evalStatus,
                                      const double           obj,
                                      const double * const   c,
                                      const double * const   objGrad,
                                      const double * const   jac,
                                            void   *         userParams);



/*------------------------------------------------------------------*/
/*     DEFINES                                                      */
/*------------------------------------------------------------------*/

/** Any numbers greater than or equal to KTR_INFBOUND in magnitude
 *  are treated as infinite by KNITRO.
 */
#define KTR_INFBOUND 1.0e20


/** Possible objective goals for the solver (objGoal in KTR_init_problem).
 */
#define KTR_OBJGOAL_MINIMIZE    0
#define KTR_OBJGOAL_MAXIMIZE    1

/** Possible values for the objective type (objType in KTR_init_problem).
 */
#define KTR_OBJTYPE_GENERAL    0
#define KTR_OBJTYPE_LINEAR     1
#define KTR_OBJTYPE_QUADRATIC  2

/** Possible values for the constraint type (cType in KTR_init_problem).
 */
#define KTR_CONTYPE_GENERAL    0
#define KTR_CONTYPE_LINEAR     1
#define KTR_CONTYPE_QUADRATIC  2

/** Possible values for the variable type (xType in KTR_mip_init_problem).
 */
#define KTR_VARTYPE_CONTINUOUS  0
#define KTR_VARTYPE_INTEGER     1
#define KTR_VARTYPE_BINARY      2


/** Possible values for the objective and constraint functions (fnType
 *  in KTR_mip_init_problem).
 */
#define KTR_FNTYPE_UNCERTAIN   0
#define KTR_FNTYPE_CONVEX      1
#define KTR_FNTYPE_NONCONVEX   2

    
/** Return codes used by KNITRO for reverse communication.
 */
#define KTR_RC_BEGINEND        0
#define KTR_RC_EVALFC          1
#define KTR_RC_EVALGA          2
#define KTR_RC_EVALH           3
#define KTR_RC_EVALX0          4  /*-- FOR INTERNAL USE, KNITRO 5.x */
#define KTR_RC_FINISHED        5  /*-- FOR INTERNAL USE, KNITRO 5.x */
#define KTR_RC_NEWPOINT        6
#define KTR_RC_EVALHV          7

/** Return codes when KNITRO terminates.
 */
#define KTR_RC_OPTIMAL              0   /*-- OPTIMAL CODE */ 
#define KTR_RC_NEAR_OPT            -100 /*-- FEASIBLE CODES */
#define KTR_RC_FEAS_XTOL           -101
#define KTR_RC_FEAS_NO_IMPROVE     -102    
#define KTR_RC_FEAS_FTOL           -103
#define KTR_RC_INFEASIBLE          -200 /*-- INFEASIBLE CODES */
#define KTR_RC_INFEAS_XTOL         -201    
#define KTR_RC_INFEAS_NO_IMPROVE   -202
#define KTR_RC_INFEAS_MULTISTART   -203
#define KTR_RC_INFEAS_CON_BOUNDS   -204 
#define KTR_RC_INFEAS_VAR_BOUNDS   -205 
#define KTR_RC_UNBOUNDED           -300 /*-- UNBOUNDED CODE */
#define KTR_RC_ITER_LIMIT          -400 /*-- LIMIT EXCEEDED CODE */
#define KTR_RC_TIME_LIMIT          -401
#define KTR_RC_FEVAL_LIMIT         -402
#define KTR_RC_MIP_EXH             -403
#define KTR_RC_MIP_FEAS_TERM       -404
#define KTR_RC_MIP_SOLVE_LIMIT     -405
#define KTR_RC_MIP_NODE_LIMIT      -406    
#define KTR_RC_CALLBACK_ERR        -500 /*-- OTHER FAILURES */
#define KTR_RC_LP_SOLVER_ERR       -501
#define KTR_RC_EVAL_ERR            -502
#define KTR_RC_OUT_OF_MEMORY       -503
#define KTR_RC_USER_TERMINATION    -504
#define KTR_RC_OPEN_FILE_ERR       -505
#define KTR_RC_BAD_N_OR_F          -506 /*-- PROBLEM DEFINITION ERROR */
#define KTR_RC_BAD_CONSTRAINT      -507 /*-- PROBLEM DEFINITION ERROR */
#define KTR_RC_BAD_JACOBIAN        -508 /*-- PROBLEM DEFINITION ERROR */
#define KTR_RC_BAD_HESSIAN         -509 /*-- PROBLEM DEFINITION ERROR */
#define KTR_RC_BAD_CON_INDEX       -510 /*-- PROBLEM DEFINITION ERROR */
#define KTR_RC_BAD_JAC_INDEX       -511 /*-- PROBLEM DEFINITION ERROR */
#define KTR_RC_BAD_HESS_INDEX      -512 /*-- PROBLEM DEFINITION ERROR */
#define KTR_RC_BAD_CON_BOUNDS      -513 /*-- PROBLEM DEFINITION ERROR */
#define KTR_RC_BAD_VAR_BOUNDS      -514 /*-- PROBLEM DEFINITION ERROR */
#define KTR_RC_ILLEGAL_CALL        -515 /*-- KNITRO CALL IS OUT OF SEQUENCE */
#define KTR_RC_BAD_KCPTR           -516 /*-- KNITRO PASSED A BAD KC POINTER */
#define KTR_RC_NULL_POINTER        -517 /*-- KNITRO PASSED A NULL ARGUMENT */
#define KTR_RC_BAD_INIT_VALUE      -518 /*-- APPLICATION INITIAL POINT IS BAD */
#define KTR_RC_NEWPOINT_HALT       -519 /*-- APPLICATION TOLD KNITRO TO HALT */
#define KTR_RC_BAD_LICENSE         -520 /*-- LICENSE CHECK FAILED */
#define KTR_RC_BAD_PARAMINPUT      -521 /*-- INVALID USER OPTION DETECTED */
#define KTR_RC_INTERNAL_ERROR      -600 /*-- CONTACT info@ziena.com */
    
/** Parameter IDs used in functions KTR_get_xxx_param and KTR_set_xxx_param.
 *  In some cases, parameter values are defined underneath the parameter ID.
 */
#define KTR_PARAM_NEWPOINT             1001
#  define KTR_NEWPOINT_NONE               0
#  define KTR_NEWPOINT_SAVEONE            1
#  define KTR_NEWPOINT_SAVEALL            2
#  define KTR_NEWPOINT_USER               3
#define KTR_PARAM_HONORBNDS            1002
#  define KTR_HONORBNDS_NO                0
#  define KTR_HONORBNDS_ALWAYS            1
#  define KTR_HONORBNDS_INITPT            2
#define KTR_PARAM_ALGORITHM            1003
#define KTR_PARAM_ALG                  1003
#  define KTR_ALG_AUTOMATIC               0
#  define KTR_ALG_AUTO                    0
#  define KTR_ALG_BAR_DIRECT              1
#  define KTR_ALG_BAR_CG                  2
#  define KTR_ALG_ACT_CG                  3
#  define KTR_ALG_IPDIRECT                1  /*-- DEPRECATED -- Please use the new  */
#  define KTR_ALG_IPCG                    2  /*-- DEPRECATED -- option names listed */
#  define KTR_ALG_ACTIVE                  3  /*-- DEPRECATED -- just above.         */
#define KTR_PARAM_BAR_MURULE           1004
#define KTR_PARAM_BARRULE              1004  /*-- DEPRECATED -- Use BAR_MURULE */
#  define KTR_BAR_MURULE_AUTOMATIC        0
#  define KTR_BAR_MURULE_AUTO             0
#  define KTR_BAR_MURULE_MONOTONE         1
#  define KTR_BAR_MURULE_ADAPTIVE         2
#  define KTR_BAR_MURULE_PROBING          3
#  define KTR_BAR_MURULE_DAMPMPC          4
#  define KTR_BAR_MURULE_FULLMPC          5
#  define KTR_BAR_MURULE_QUALITY          6
#define KTR_PARAM_BAR_FEASIBLE         1006     
#define KTR_PARAM_FEASIBLE             1006 /*-- DEPRECATED -- Use BAR_FEASIBLE */
#  define KTR_BAR_FEASIBLE_NO             0    
#  define KTR_BAR_FEASIBLE_STAY           1
#  define KTR_BAR_FEASIBLE_GET            2
#  define KTR_BAR_FEASIBLE_GET_STAY       3
#  define KTR_FEASIBLE_NO                 0 /*-- DEPRECATED -- Please use the new  */
#  define KTR_FEASIBLE_ALWAYS             1 /*-- DEPRECATED -- option names above */   
#define KTR_PARAM_GRADOPT              1007
#  define KTR_GRADOPT_EXACT               1
#  define KTR_GRADOPT_FORWARD             2
#  define KTR_GRADOPT_CENTRAL             3
#define KTR_PARAM_HESSOPT              1008
#  define KTR_HESSOPT_EXACT               1
#  define KTR_HESSOPT_BFGS                2
#  define KTR_HESSOPT_SR1                 3
#  define KTR_HESSOPT_FINITE_DIFF         4
#  define KTR_HESSOPT_PRODUCT             5
#  define KTR_HESSOPT_LBFGS               6
#define KTR_PARAM_BAR_INITPT           1009
#  define KTR_BAR_INITPT_AUTO             0
#  define KTR_BAR_INITPT_YES              1
#  define KTR_BAR_INITPT_NO               2
#define KTR_PARAM_LPSOLVER             1012
#  define KTR_LP_INTERNAL                 1
#  define KTR_LP_CPLEX                    2
#define KTR_PARAM_MAXCGIT              1013
#define KTR_PARAM_MAXIT                1014
#define KTR_PARAM_OUTLEV               1015
#  define KTR_OUTLEV_NONE                 0
#  define KTR_OUTLEV_SUMMARY              1
#  define KTR_OUTLEV_MAJORIT10            2  /*-- DEPRECATED -- Use ITER_10 */
#  define KTR_OUTLEV_ITER_10              2
#  define KTR_OUTLEV_MAJORIT              3  /*-- DEPRECATED -- Use ITER */    
#  define KTR_OUTLEV_ITER                 3
#  define KTR_OUTLEV_ALLIT                4  /*-- DEPRECATED -- Use ITER_VERBOSE */
#  define KTR_OUTLEV_ITER_VERBOSE         4
#  define KTR_OUTLEV_ALLIT_X              5  /*-- DEPRECATED -- Use ITER_X */
#  define KTR_OUTLEV_ITER_X               5
#  define KTR_OUTLEV_ALL                  6
#define KTR_PARAM_OUTMODE              1016
#  define KTR_OUTMODE_SCREEN              0
#  define KTR_OUTMODE_FILE                1
#  define KTR_OUTMODE_BOTH                2
#define KTR_PARAM_SCALE                1017
#  define KTR_SCALE_NEVER                 0
#  define KTR_SCALE_ALLOW                 1
#define KTR_PARAM_SHIFTINIT            1018  /*-- DEPRECATED -- Use HONORBNDS */
#define KTR_PARAM_SOC                  1019
#  define KTR_SOC_NO                      0
#  define KTR_SOC_MAYBE                   1    
#  define KTR_SOC_YES                     2
#define KTR_PARAM_DELTA                1020
#define KTR_PARAM_BAR_FEASMODETOL      1021
#define KTR_PARAM_FEASMODETOL          1021  /*-- DEPRECATED -- Use BAR_FEASMODETOL */   
#define KTR_PARAM_FEASTOL              1022
#define KTR_PARAM_FEASTOLABS           1023
#define KTR_PARAM_MAXTIMECPU           1024
#define KTR_PARAM_BAR_INITMU           1025
#define KTR_PARAM_MU                   1025  /*-- DEPRECATED -- Use BAR_INITMU */
#define KTR_PARAM_OBJRANGE             1026
#define KTR_PARAM_OPTTOL               1027
#define KTR_PARAM_OPTTOLABS            1028
#define KTR_PARAM_PIVOT                1029
#define KTR_PARAM_XTOL                 1030
#define KTR_PARAM_DEBUG                1031
#  define KTR_DEBUG_NONE                  0
#  define KTR_DEBUG_PROBLEM               1
#  define KTR_DEBUG_EXECUTION             2
#define KTR_PARAM_MULTISTART           1033
#  define KTR_MULTISTART_NO               0
#  define KTR_MULTISTART_YES              1
#define KTR_PARAM_MSMAXSOLVES          1034
#define KTR_PARAM_MSMAXBNDRANGE        1035
#define KTR_PARAM_MSMAXTIMECPU         1036
#define KTR_PARAM_MSMAXTIMEREAL        1037
#define KTR_PARAM_LMSIZE               1038
#define KTR_PARAM_MAXCROSSIT           1039
#define KTR_PARAM_MAXTIMEREAL          1040
#define KTR_PARAM_PRECOND              1041
#  define KTR_PRECOND_NONE                0
#  define KTR_PRECOND_CHOL                1
#define KTR_PARAM_BLASOPTION           1042
#  define KTR_BLASOPTION_KNITRO           0
#  define KTR_BLASOPTION_INTEL            1
#  define KTR_BLASOPTION_DYNAMIC          2
#define KTR_PARAM_BAR_MAXREFACTOR      1043
#define KTR_PARAM_BAR_MAXBACKTRACK     1044
#define KTR_PARAM_BLASOPTIONLIB        1045
#define KTR_PARAM_OUTAPPEND            1046
#  define KTR_OUTAPPEND_NO                0
#  define KTR_OUTAPPEND_YES               1
#define KTR_PARAM_OUTDIR               1047    
#define KTR_PARAM_CPLEXLIB             1048
#define KTR_PARAM_BAR_PENRULE          1049
#  define KTR_BAR_PENRULE_AUTO            0
#  define KTR_BAR_PENRULE_SINGLE          1
#  define KTR_BAR_PENRULE_FLEX            2
#define KTR_PARAM_BAR_PENCONS          1050    
#  define KTR_BAR_PENCONS_AUTO            0
#  define KTR_BAR_PENCONS_NONE            1
#  define KTR_BAR_PENCONS_ALL             2
#  define KTR_BAR_PENCONS_INFEAS          3
#define KTR_PARAM_MSNUMTOSAVE          1051
#define KTR_PARAM_MSSAVETOL            1052
#define KTR_PARAM_PRESOLVEDEBUG        1053  /*-- FOR AMPL ONLY */
#  define KTR_PRESOLVEDBG_NONE            0
#  define KTR_PRESOLVEDBG_BASIC           1
#  define KTR_PRESOLVEDBG_VERBOSE         2
#define KTR_PARAM_MSTERMINATE          1054
#  define KTR_MSTERMINATE_MAXSOLVES       0
#  define KTR_MSTERMINATE_OPTIMAL         1
#  define KTR_MSTERMINATE_FEASIBLE        2
#define KTR_PARAM_MSSTARTPTRANGE       1055
#define KTR_PARAM_INFEASTOL            1056
#define KTR_PARAM_LINSOLVER            1057
#  define KTR_LINSOLVER_AUTO              0
#  define KTR_LINSOLVER_INTERNAL          1
#  define KTR_LINSOLVER_HYBRID            2        
#  define KTR_LINSOLVER_DENSEQR           3
#  define KTR_LINSOLVER_MA27              4
#  define KTR_LINSOLVER_MA57              5
#define KTR_PARAM_BAR_DIRECTINTERVAL   1058
    
#define KTR_PARAM_MIP_METHOD           2001
#  define KTR_MIP_METHOD_AUTO             0
#  define KTR_MIP_METHOD_BB               1
#  define KTR_MIP_METHOD_HQG              2
#define KTR_PARAM_MIP_BRANCHRULE       2002
#  define KTR_MIP_BRANCH_AUTO             0
#  define KTR_MIP_BRANCH_MOSTFRAC         1
#  define KTR_MIP_BRANCH_PSEUDOCOST       2
#  define KTR_MIP_BRANCH_STRONG           3    
#define KTR_PARAM_MIP_SELECTRULE       2003
#  define KTR_MIP_SEL_AUTO                0
#  define KTR_MIP_SEL_DEPTHFIRST          1
#  define KTR_MIP_SEL_BESTBOUND           2
#  define KTR_MIP_SEL_COMBO_1             3
#define KTR_PARAM_MIP_INTGAPABS        2004
#define KTR_PARAM_MIP_INTGAPREL        2005
#define KTR_PARAM_MIP_MAXTIMECPU       2006
#define KTR_PARAM_MIP_MAXTIMEREAL      2007
#define KTR_PARAM_MIP_MAXSOLVES        2008
#define KTR_PARAM_MIP_INTEGERTOL       2009
#define KTR_PARAM_MIP_OUTLEVEL         2010
#  define KTR_MIP_OUTLEVEL_NONE           0
#  define KTR_MIP_OUTLEVEL_ITERS          1
#define KTR_PARAM_MIP_OUTINTERVAL      2011
#define KTR_PARAM_MIP_OUTSUB           2012
#  define KTR_MIP_OUTSUB_NONE             0
#  define KTR_MIP_OUTSUB_YES              1
#  define KTR_MIP_OUTSUB_YESPROB          2
#define KTR_PARAM_MIP_DEBUG            2013
#  define KTR_MIP_DEBUG_NONE              0
#  define KTR_MIP_DEBUG_ALL               1
#define KTR_PARAM_MIP_IMPLICATNS       2014  /*-- USE LOGICAL IMPLICATIONS */
#  define KTR_MIP_IMPLICATNS_NO           0
#  define KTR_MIP_IMPLICATNS_YES          1
#define KTR_PARAM_MIP_GUB_BRANCH       2015  /*-- BRANCH ON GENERALIZED BOUNDS */
#  define KTR_MIP_GUB_BRANCH_NO           0
#  define KTR_MIP_GUB_BRANCH_YES          1
#define KTR_PARAM_MIP_KNAPSACK         2016  /*-- KNAPSACK CUTS */
#  define KTR_MIP_KNAPSACK_NO             0  /*--   NONE */
#  define KTR_MIP_KNAPSACK_INEQ           1  /*--   ONLY FOR INEQUALITIES */
#  define KTR_MIP_KNAPSACK_INEQ_EQ        2  /*--   FOR INEQS AND EQS */
#define KTR_PARAM_MIP_ROUNDING         2017
#  define KTR_MIP_ROUND_AUTO              0
#  define KTR_MIP_ROUND_NONE              1  /*-- DO NOT ATTEMPT ROUNDING */
#  define KTR_MIP_ROUND_HEURISTIC         2  /*-- USE FAST HEURISTIC */
#  define KTR_MIP_ROUND_NLP_SOME          3  /*-- SOLVE NLP IF LIKELY TO WORK */
#  define KTR_MIP_ROUND_NLP_ALWAYS        4  /*-- SOLVE NLP ALWAYS */
#define KTR_PARAM_MIP_ROOTALG          2018
#  define KTR_MIP_ROOTALG_AUTO            0
#  define KTR_MIP_ROOTALG_BAR_DIRECT      1
#  define KTR_MIP_ROOTALG_BAR_CG          2
#  define KTR_MIP_ROOTALG_ACT_CG          3
#define KTR_PARAM_MIP_LPALG            2019
#  define KTR_MIP_LPALG_AUTO              0
#  define KTR_MIP_LPALG_BAR_DIRECT        1
#  define KTR_MIP_LPALG_BAR_CG            2
#  define KTR_MIP_LPALG_ACT_CG            3
#define KTR_PARAM_MIP_TERMINATE        2020
#  define KTR_MIP_TERMINATE_OPTIMAL       0
#  define KTR_MIP_TERMINATE_FEASIBLE      1
#define KTR_PARAM_MIP_MAXNODES         2021
#define KTR_PARAM_MIP_HEURISTIC        2022
#  define KTR_MIP_HEURISTIC_AUTO          0
#  define KTR_MIP_HEURISTIC_NONE          1
#  define KTR_MIP_HEURISTIC_FEASPUMP      2
#  define KTR_MIP_HEURISTIC_MPEC          3    
#define KTR_PARAM_MIP_HEUR_MAXIT       2023
#define KTR_PARAM_MIP_HEUR_MAXTIMECPU  2024
#define KTR_PARAM_MIP_HEUR_MAXTIMEREAL 2025
#define KTR_PARAM_MIP_PSEUDOINIT       2026
#  define KTR_MIP_PSEUDOINIT_AUTO         0
#  define KTR_MIP_PSEUDOINIT_AVE          1
#  define KTR_MIP_PSEUDOINIT_STRONG       2
#define KTR_PARAM_MIP_STRONG_MAXIT     2027
#define KTR_PARAM_MIP_STRONG_CANDLIM   2028    
#define KTR_PARAM_MIP_STRONG_LEVEL     2029
    
#ifdef __cplusplus
}
#endif

#endif     /*-- KNITRO_H__ */
